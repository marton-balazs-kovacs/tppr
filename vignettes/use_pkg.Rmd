---
title: "Using the package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{use_pkg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Setup

First, you have to install the package.

```{r install, eval = FALSE}
# install.packages("devtools")
devtools::install_github("marton-balazs-kovacs/tppr")
```

Second you have to load the package.

```{r load, message = FALSE, warning = FALSE}
library(tppr)
```

# Setting the analysis parameters

The analysis depends on preset parameters that are saved as a list of values in the analysis_params datafile. This datafile is part of the package. If you want to know more about the default analysis parameters check `?tppr::analysis_params`.

You can load the analysis parameters datafile in the current workspace.

```{r}
data(analysis_params)
```

You can also modify the parameters after loading.

Getting the probability of M0:

```{r}
analysis_params$m0_prob
```

Changing the value:
 
```{r, eval = FALSE}
analysis_params$m0_prob <- 0.53
```
 
# Import data

You can run the analysis on several different data types:

* Example dataset where M0 is simulated to be true
* Example dataset where M1 is simulated to be true
* Example data generated by yourself
* The collected pilot dataset
* The collected test dataset
* The collected live dataset

In the following we show you how to load each type of data.

## Example datasets

The example datasets are included in the package. If you want to know more about the datasets you can use the `?tppr::exampl_m0` and the `?tppr::exampl_m1` functions to read the documentation.

```{r}
# To load the dataset where M0 is simulated to be true
data(example_m0)

# To load the dataset where M1 is simulated to be true
data(example_m1)
```

## Generate example dataset

It is also possible to generate your own example dataset.

```{r, eval = FALSE}
my_tppr_data <- generate_example_data()
```

## Collected datasets

You can download and read the collected data from the projects Github repository.
There are three types of collected data:

* test: The data are collected by testing the data collection program.
* pilot: The data are collected during the pilot study.
* live: The data are collected during live testing. These data will go in the analysis and the results will be presented in the paper.

```{r}
# Read live data
tpp_raw_data <- read_data(type = "live")

# For testing purposes we will use the example_m0 dataset from now on
tpp_raw_data <- example_m0
```

# Cleaning the dataset

After reading the raw data that contains all the trials during data cleaning the empty trials are excluded and only the erotic trials are kept.

However, this step is included in the primary confirmatory analysis function `analysis_confirmatory`, therefore you do not have to run it separately.

```{r}
tpp_processed_data <- clean_data(raw_data = tpp_raw_data)
```

# Calculate study descriptives

All the descriptive results of the study can be calculated with the `?tppr::sample_descriptives` function. The function returns a list of the descriptive results that can be later used to populate the research paper.

The function runs at the latest passed checkpoint, unless it is indicated differently in the which_checkpoint argument.

```{r}
descriptive_results <- sample_descriptives(raw_data = tpp_raw_data, which_checkpoint = NA_integer_)
```

# Checking the current and the next checkpoint

To get information about the currently passed checking point based on the number of trials (either all trials or only the erotic trials) the `?tppr::tell_checkpoint` function can be be used.

```{r}
checkpoint <- tell_checkpoint(df = tpp_processed_data)
```

The number of valid erotic trials:

```{r}
checkpoint$total_n
```

The closest checkpoint that is passed:

```{r}
checkpoint$current_checkpoint
```

Next closest checkpoint:

```{r}
checkpoint$next_checkpoint
```

Row number of the last row at the current checkpoint:

```{r}
checkpoint$last_row
```

# Run the primary confirmatory analysis
## The structure of the analysis

First, the primary confirmatory analysis splits the data at each passed checking point and saves the results into a list of dataframes. This step can be done separately with the `tppr::split_data` function.

```{r}
tpp_split_data <- split_data(processed_data = tpp_processed_data)
```

Second, the code iterates trough the splitted dataframes and calculates the mixed-effects logistic regression and Bayes factors with three different priors.

These calculations can be run separately.
* Mixed-effects logistic regression: `?tppr::confirmatory_mixed_effect`
* Bayes factor with three different priors: `?tppr:confirmatory_bayes_factor`

Third, based on the results of the 4 primary analysis the function makes an inference at each stopping point.
* M1: If all the four analysis supports the M1 model
* M0: If all the four analysis supports the M0 model
* Ongoing: If the four analysis do not support the same model and the last checking point is not reached
* Inconclusive: If the four analysis do not support the same model and the last checking point is reached

The primary analysis function will run all these subfunctions and return the result as a dataframe.

To run the primary analysis function run the following code on the processed data:

```{r}
confirmatory_results <- analysis_confirmatory(raw_data = tpp_raw_data)
```

## Calculate the cumulative Bayes factor

For the primary analysis plot we have to calculate the cumulative Bayes factors with the three priors for every trial.

```{r}
cumulative_results <- cumulative_bayes_factor(df = tpp_raw_data)
```

## Visualise the result

To visualize the results of the primary confirmatory analysis the `?tppr::plot_confrimatory` can be used.

```{r}
plot_confirmatory(cumulative_results = cumulative_results)
```

# Run the robustness analysis

If the primary confirmatory analysis did not reach a conclusion (either support for M0 or for M1), the robustness analysis inference will be NA.

In our example case the analysis supports M0 at the first checkpoint. If multiple checkpoints were reached we could run the robustness analysis for multiple checkpoints, or we could extract the results of the confirmatory analysis for the last checkpoint with the following code.

By default, the `analysis_robustness` and the `analysis_exploratory` functions extract the last row of th primary confirmatory analysis results output.

We could run the robustness analysis with the following code on the last row of the primary analysis results:

```{r}
robustness_results <- analysis_robustness(confirmatory_results = confirmatory_results)
```

## Visualise the result

```{r}
# plot_robustness(posterior_density, hdi_mode, hdi_l, hdi_u, mixed_ci_width, mixed_ci_l, mixed_ci_u)
```

# Run the exploratory analysis

```{r}
exploratory_results <- analysis_exploratory(df = tpp_raw_data)
```

## Visualize the results

```{r}
# plot_exploratory(success_rates_theoretical_prop, success_rates_empirical_prop, possible_success_rates)
```

